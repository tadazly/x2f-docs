---
sidebar_position: 4
---

# FAQ

## Table Conversion Issues

### When will the output_censored directory be generated?

- When generating a single table, if `--censored-fields <fields>` is passed, both **censored version** and **complete version** output files will be generated, corresponding to the `output_censored/` and `output/` directories respectively.

- When batch generating tables, if `censoredTable` or `censoredFields` fields are configured in $tables.xlsx, both **censored version** and **complete version** output files will be generated. Tables marked with `censoredTable` will **not** be output to the `output_censored/` directory, only to `output/`.

- If `censoredTable` or `censoredFields` fields are not configured, only one `output/` will be generated.

### About file_identifier

When using x2f, the .fbs file contentâ€™s **SHA-256** hash is calculated, and the first four characters are used as the file_identifier.

You can use the `BufferHasIdentifier` method in the generated code to verify whether the binary file matches the code. (If you are using a Unity Loader class generated by x2f, the `Load` function will automatically perform this validation.)

### uint64/int64 Precision Issues

When storing numbers like 9007199254740993 in the table, precision may be lost. You can set the cell to text format to preserve precision.

## Runtime Issues

### [ C# ] System.OverflowException: Value was either too large or too small for an Int16.

- Trigger condition: When verifying the buffer, for example:

    ```csharp
    Xls.SomeTable.Instance.LoadAsync();
    Xls.MergeTableLoader.LoadAllAsync();
    ```

- Cause: When there is a large amount of data in the table, the offset exceeds the range of the `short` type in the verification method.

    ```csharp title="FlatBuffers/FlatBufferVerify.cs" {8} showLineNumbers
    private short GetVRelOffset(int pos, short vtableOffset)
    {
        short VOffset = 0;
        // Used try/catch because pos typa as int 32bit
        try
        {
        // First, get vtable offset
        short vtable = Convert.ToInt16(pos - ReadSOffsetT(verifier_buffer, pos));
        // Check that offset points to vtable area (is smaller than vtable size)
        if (vtableOffset < ReadVOffsetT(verifier_buffer, vtable))
        {
            // Now, we can read offset value - TODO check this value against size of table data
            VOffset = ReadVOffsetT(verifier_buffer, vtable + vtableOffset);
        }
        // (...)
    }
    ```

- Solutions:

    1. Modify the `GetVRelOffset` method in FlatBuffers to use `int` type instead of `short` type.

    ```csharp title="FlatBuffers/FlatBufferVerify.cs" {2} showLineNumbers
    // short vtable = Convert.ToInt16(pos - ReadSOffsetT(verifier_buffer, pos));
    // ðŸ‘‡ Change to this
    int vtable = pos - ReadSOffsetT(verifier_buffer, pos);
    ```

    2. Or modify the `TableValidator.Validate` method in UnityTemplate to only verify that the `identifier` matches, without verifying the `buffer` structure. 